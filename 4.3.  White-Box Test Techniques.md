
Because of their popularity and simplicity, this section focuses on two code-related white-box test techniques:

* Statement testing
* Branch testing

There are more rigorous white-box test techniques that are used in some safety-critical, mission-critical, or high-integrity environments to achieve more thorough code coverage.  There are also white-box test techniques used in higher test levels (e.g., API Testing), or using coverage not related to code (e.g., neuron coverage in neural network testing).  These techniques are not discussed in this syllabus.

## 4.3.1. Statement Testing and Statement Coverage

In statement testing, the coverage items are executable statements.  The aim is to design test cases that exercise statements in the code until an acceptable level of coverage is achieved.  Coverage is measured as the number of statements exercised by the test cases divided by the total number of executable statements in the code, and is expressed as a percentage.

When 100% statement coverage is achieved, it ensures that all executable statements in the code have been exercised at least once.  In particular, this means that each statement with a defect will be executed, which may cause a failure demonstrating the presence of the defect.  However, exercising a statement with a test case will not detect defects in all cases.  For example, it may not detect defects that are data dependent (e.g., a division by zero that only fails when a denominator is set to zero).  Also, 100% statement coverage does not ensure that all the decision logic has been tested as, for instance, it may not exercise all the branches (see chapter [[4.3.  White-Box Test Techniques#4.3.2. Branch Testing and Branch Coverage | 4.3.2]]) in the code.

## 4.3.2. Branch Testing and Branch Coverage

A branch is a transfer of control between two nodes in the control flow graph, which shows the possible sequences in which source code statements are executed in the test object. Each transfer of control can be either unconditional (i.e., straight-line code) or conditional (i.e., a decision outcome).

In branch testing the coverage items are branches and the aim is to design test cases to exercise branches in the code until an acceptable level of coverage is achieved.  Coverage is measured as the number of branches exercised by the test cases divided by the total number of branches and is expressed as a percentage.

When 100% branch coverage is achieved, all branches in the code, unconditional and conditional, are exercised by test cases.  Conditional branches typically correspond to a true or false outcome from an "if...then" decision, an outcome from a switch/case statement or a decision to exist or continue in a loop.  However, exercising a branch with a test case will not detect defects in all cases.  For example, it may not detect defects requiring the execution of a specific path in a code.

Branch coverage subsumes statement coverage.  This means that any set of test cases achieving 100% branch coverage also achieves 100% statement coverage (but not vice versa).

## 4.3.3 The Value of White-box Testing

A fundamental strength that all white-box test techniques share is that the entire software implementation is taken into account during testing, which facilitates defect detection even when the software specification is vague, outdated, or incomplete.  A corresponding weakness is that if the software does not implement one or requirements, white-box testing may not detect the resulting defects of omission ([[Structured Testing | Watson 1996]]).

White-box test techniques can be used in static testing (e.g., during dry runs of code). They are well suited to reviewing code not yet ready for execution ([[The Complete Guide to Software Testing | Hetzel 1988]]), pseudocode and other high-level or top-down logic which can be modeled with a control flow graph.

Preforming only black-box testing does not provide a measure of actual code coverage.  White-box coverage measures provide an objective measurement of coverage and the necessary information to allow additional tests to be generated to increase this coverage, and subsequently increase confidence in the code. 

