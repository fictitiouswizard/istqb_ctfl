
##  5.1.1.  Purpose and Content of a Test Plan

A test plan describes the test objectives, resources and processes for a test project.  A test plan:

* Documents the means and schedule for achieving test objectives
* Helps to ensure that the performed test activities will meet the established criteria
* Serves as a means of communication with team members and other stakeholders
* Demonstrates that testing will adhere to the existing test policy and test strategy (or explains whey the testing will deviate from them)

Test planning guides the tester's thinking and forces the testers to confront the future challenges related to risks, schedules, people, tools, costs, effort, etc.  The process of preparing a test plan is a useful way to think through the efforts needed to achieve the test objectives.

The typical content of a test plan includes:

* Context of testing (e.g., test scope, test objectives, test basis)
* Assumptions and constraints of the test project
* Stakeholders (e.g., roles, responsibilities, relevance to testing, hiring and training needs)
* Communication (e.g., forms and frequency of communication, documentation templates)
* Risk register (e.g., product risks, project risks)
* Test approach (e.g., test levels, test types, test techniques, test deliverables, entry criteria and exit criteria, independence of testing, metrics to be collected, test data requirements, test environment requirements, deviations from the test policy and test strategy)
* Budget and schedule

More details about the test plan and its content can be found in the [[ISO-IEC-IEEE 29119-3 | ISO/IEC/IEEE 29119-3 standard]].

##  5.1.2.  Tester's Contribution to Iteration and Release Planning

In iterative SDLC's, typically two kinds of planning occur: release planning and iteration planning.

Release planning looks ahead to the release of a product, defines and re-defines the product backlog, and may involve refining larger user stories into a set of smaller user stories.  It also serves as the bases for the test approach and test plan across all iterations.  Testers involved in release planning participate in writing testable user stories and acceptance criteria (see [[4.5.  Collaboration-based Test Approaches | section 4.5]]), participants in project and quality risk analyses (see [[5.2.  Risk Management | section 5.2]]), estimate test effort associated with user stories (see [[5.1.  Test Planning#5.1.4. Estimation Techniques | section 5.1.4]]), determine the test approach, and plan the testing for release.

Iteration planning looks ahead to the end of a single iteration and is concerned with the iteration backlog.  Testers involved in iteration planning participate in the detailed risk analysis of user stories, determine the testability of user stories, break down user stories into tasks (particularly testing tasks), estimate test effort for all testing tasks, and identify and refine functional and non-functional aspects of the test object.

##  5.1.3.  Entry Criteria and Exit Criteria

Entry criteria define the preconditions for undertaking a given activity.  If entry criteria are not met, it is likely that the activity will prove to be more difficult, time-consuming, costly, and riskier.  Exit criteria define what must be achieved to declare an activity completed.  Entry criteria and exit criteria should be defined for each test level, and will differ based on the test objectives.

Typical entry criteria include: availability of resources (e.g., people, tools, environments test data, budget, time), availability of testware (e.g., test basis, testable requirements, user stories, test cases), and initial quality level of test object (e.g., all smoke tests have passed).

Typical exit criteria include: measures of thoroughness (e.g., achieved level of coverage, number of unresolved defects, defect density, number of failed test cases), and binary "yes/no" criteria (e.g., planned tests have been executed, static testing has been performed, all defects found are reported, all regression tests are automated).

Running out of time or budget can also be viewed as valid exit criteria.  Even without other exit criteria being satisfied, it can be acceptable to end testing under such circumstances, if the stakeholders have reviewed and accepted the risk to go live without further testing.

In Agile software development, exit criteria are often called Definition of Done, defining the team's objective metrics for a releasable item.  Entry criteria that a user story must fulfill to start the development and/or testing activities are called Definition of Ready.

##  5.1.4.  Estimation Techniques

Test effort estimation involves predicting the amount of test-related work needed to meet the test objectives of a test project.  It is important to make it clear to the stakeholders that the estimate is based on a number of assumptions and is always subject to estimation error.  Estimation for small tasks is usually more accurate than for the large ones.  Therefore, when estimating a large task, it can be decomposed into a set of smaller tasks which then in turn can be estimated.

In this syllabus, the following four estimation techniques are described.

**Estimation based on ratios**.  In this metrics-based technique, figures are collected from previous project within the organization, which makes it possible to derive "standard" ratios for similar projects.  The ratios of an organization's own projects (e.g., taken from historical data) are generally the best source to use in the estimation process.  These standard ratios can then be used to estimate  the test effort for the new project.  For example, if in the previous project the development-to-test effort ratio was 3:2, and in the current project the development effort is expected to be 600 person-days, the test effort can be estimated to be 400 person-days.

**Extrapolation**.  In this metrics-based technique, measurements are made as early as possible in the current project to gather the data.  Having enough observations, the effort required for the remaining work can be approximated by extrapolating  this data (usually by applying a mathematical model).  This method is very suitable in iterative SDLCs.  For example, the team may extrapolate the test effort in the forthcoming iteration as the averaged effort from the last three iterations.

**Wideband Delphi**.  In this iterative, expert-based technique, experts make experience-based estimations.  Each expert, in isolation, estimates the effort.  The results are collected and if there are deviations of an expert's estimate that are out of range of the agreed upon boundaries, the experts discuss their current estimates.  Each expert is then asked to make a new estimation based on that feedback, again in isolation.  This process is repeated until consensus is reached.  Planning Poker is a variant of Wideband Delphi, commonly used in Agile software development.  In Planning Poker, estimates are usually made using cards with numbers that represent the effort size.

**Three-point estimation**.  In this expert-based technique, three estimations are made by the experts: the most optimistic estimation (a), the most likely estimation (m) and the most pessimistic estimation (b).  The final estimate (E) is their weighted arithmetic mean.  In the most popular version of this technique, the estimate is calculated as E - (a + 4\*m + b) / 6.  The advantage of this technique is that it allows the experts to calculate the measurement error: SD = (b - a) / 6.  For example, if the estimates (in person-hours) are: a=6, m=9 and b=18, then the final estimation is 10 + or - 2 person-hours (i.e., between 8 and 12 person-hours), because E = (6 + 4 * 9 + 18) / 6 = 10 and SD = (18 - 6) / 6 = 2.

See ([[Metrics and Models in Software Quality Engineering | Kan 2003]], [[TMap Next for result-driven testing | Koomen 2006]], [[The Certified Software Quality Engineer Handbook | Westfall 2009]]) for these and many other test estimation techniques.

##  5.1.5.  Test Case Prioritization

Once the test cases and test procedures are specified and assembled into test suites, these test suites can be arranged in a test execution schedule that defines the order in which they are to be run.  When prioritizing test cases, different factors can be taken into account.  The most commonly used test case prioritization strategies are as follows:

* Risk-based prioritization, where the order of test execution is based on the results of risk analysis (see [[5.2.  Risk Management#5.2.3. Product Risk Analysis | section 5.2.3]]).  Test cases covering the most important risks are executed first.
* Coverage-based prioritization, where the order of test execution is based on coverage (e.g., statement coverage).  Test cases achieving the highest coverage are executed first.  In another variant, called additional coverage prioritization, the test cased achieving the highest coverage is executed first; each subsequent test case is the one that achieves the highest additional coverage.
* Requirements-based prioritization, where the order of test execution is based on the priorities of the requirements traced back to the corresponding test cases.  Requirement priorities are defined by stakeholders.  Test cases related to the most important requirements are executed first.

Ideally, test cases would be ordered to run based on their priority levels, using, for example, one of the above-mentioned prioritization strategies.  However, this practice may not work if the test cases or the features being tested have dependencies.  If a test case with a higher priority is dependent on a test case with a lower priority, the lower priority test case must be executed first.

The order of test execution must also take into account the availability of resources.  For example, the required test tools, test environments or people that may only be available for a specific time window.

##  5.1.6.  Test Pyramid

The test pyramid is a model showing that different tests may have different granularity.  The test pyramid model supports the team in test automation and in test effort allocation by showing that different test objectives are supported by different levels of test automation.  The pyramid layers represent groups of tests.  The higher the layer, the lower the test granularity, the lower the test isolation (i.e., the degree of dependency on other elements of the system) and the higher the test execution time.  Tests in the bottom layer are small, isolated, fast, and check a small piece of functionality, so usually a lot of them are needed to achieve a reasonable coverage.  The top layer represents complex, high-level, end-to-end tests.  These high-level tests are generally slower than the tests from the lower layers, and they typically check a large piece of functionality, so usually just a few of them are needed to achieve a reasonable level of coverage.  The number and naming of the layers may differ.  For example, the original test pyramid model ([[Succeeding with Agile | Cohn 2009]]) defines three layers: "unit tests", "service tests" and "UI tests".  Another popular model defines unit (component) tests, integration (component integration) tests, and end-to-end tests.  Other test levels (see [[2.2.  Test Levels and Test Types#2.2.1. Test Levels | section 2.2.1]]) can also be used.

##  5.1.7.  Testing Quadrants

The testing quadrants, defined by Brian Marick ([[Exploration through Example | Marick 2003]], [[Agile Testing | Crispin 2008]]), group the test levels with the appropriate test types, activities, test techniques and work products in the Agile software development.  The model supports test management in visualizing these to ensure that all appropriate test types and test levels are included in the SDLC and in understanding that some test types are more relevant to certain test levels than others.  This model also provides a way to differentiate and describe the test types to all stakeholders, including developers, testers, and business representatives.

In this model, tests can be business facing or technology facing.  Tests can also support the team (i.e., guide the development) or critique the product (i.e., measure its behavior against the expectations).  The combination of these two viewpoints determines the four quadrants:

* Quadrant Q1 (technology facing, support the team).  This quadrant contains component tests and component integration tests.  These tests should be automated and included in the CI process.
* Quadrant Q2 (business facing, support the team).  This quadrant contains functional tests, examples, user story tests, user experience prototypes, API testing, and simulations.  These tests check the acceptance criteria and can be manual or automated.
* Quadrant Q3 (business facing, critique the product).  This quadrant contains exploratory testing, usability testing, user acceptance testing.  These tests are user-oriented and often manual.
* Quadrant Q4 (technology facing, critique the product).  This quadrant contains smoke tests and non-functional tests (except usability tests).  These tests are often automated.